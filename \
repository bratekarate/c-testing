#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>

int main() {

  // create socket
  int socket_fd;
  if ((socket_fd = socket(AF_UNIX, SOCK_STREAM, 0)) == 0) {
    perror("socket failed");
    exit(EXIT_FAILURE);
  }

  // setup socket address
  struct sockaddr_un addr;
  memset(&addr, '\0', sizeof(struct sockaddr_un));
  addr.sun_family = AF_UNIX;
  strncpy(addr.sun_path, "/tmp/mysock", sizeof(addr.sun_path));
  socklen_t socklen = sizeof(struct sockaddr_un);

  // TODO: remove old socket file on error
  // bind socket
  unlink("/tmp/mysock");
  int bind_res;
  if ((bind_res = bind(socket_fd, (struct sockaddr *)&addr, socklen)) != 0) {
    perror("bind failed");
    exit(EXIT_FAILURE);
  }

  // start listening
  int listen_res;
  if ((listen_res = listen(socket_fd, 1)) != 0) {
    perror("listen failed");
    exit(EXIT_FAILURE);
  }

#define BUFSIZE 1000
  char *buf = malloc(BUFSIZE * sizeof(char));

  // listen to connections forever
  while (1) {
    memset(buf, '\0', BUFSIZE);

    // accept connection
    int acc_res;
    if ((acc_res = accept(socket_fd, (struct sockaddr *)&addr, &socklen)) < 1) {
      perror("accept failed");
      exit(EXIT_FAILURE);
    }

    // read message
    int read_res;
    if ((read_res = read(acc_res, buf, BUFSIZE)) != 0) {
      printf("%d\n", read_res);
      perror("read failed");
      exit(EXIT_FAILURE);
    }

    printf("%s\n", buf);
  }
  free(buf);
}
